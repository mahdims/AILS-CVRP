void Solution::resetSisrBuffers()
{
    sisrAbsent.clear();
    sisrInsertionStack.clear();
}

// ============================================================================
// SISR HELPER FUNCTION
// ============================================================================

// ============================================================================
// SISR RUIN METHOD - PAPER-COMPLIANT IMPLEMENTATION
// ============================================================================
// Based on: Christiaens & Vanden Berghe (2020), Transportation Science
// Algorithm 2: Ruin Method (Section 5.2, Page 7)
// Equations 5-9: Parameter calculation
// ============================================================================

// Helper: Calculate SISR parameters (Equations 5-7)
Solution::SISRParams Solution::calculateSISRParameters(const SISRConfig &config, std::mt19937 &rng)
{
    SISRParams params;
    const double avgRemoved = std::max(0.0, config.avgRemoved); // c̄ from paper
    const double maxStringLengthCfg = std::max(0.0, config.maxStringLength);

    // ===== PAPER EQUATION 5: l_s^max = min{Lmax, average_tour_cardinality} =====
    double sum_cardinality = 0.0;
    int num_non_empty = 0;
    for (const auto &route : routes)
    {
        if (route.numCus > 0)
        {
            sum_cardinality += route.numCus;
            num_non_empty++;
        }
    }

    if (num_non_empty == 0)
    {
        params.ell_s_max = 0;
        params.k_s = 0;
        return params;
    }

    double avg_cardinality = sum_cardinality / num_non_empty;
    params.ell_s_max = std::min(maxStringLengthCfg, avg_cardinality);

    // ===== PAPER EQUATION 6: k_s^max = floor(4*c̄/(1 + l_s^max)) - 1 =====
    double k_s_max = std::floor(4.0 * avgRemoved / (1.0 + params.ell_s_max)) - 1;

    // ===== PAPER EQUATION 7: k_s = floor(U(1, k_s^max + 1)) =====
    std::uniform_real_distribution<double> k_s_dist(1.0, k_s_max + 1.0);
    params.k_s = static_cast<int>(std::floor(k_s_dist(rng)));

    // Log parameters if tracing enabled
    if (data && data->trace_level >= 3)
    {
        Logger::debug("SISR Ruin Parameters: avg_card=", avg_cardinality,
                      " ell_s_max=", params.ell_s_max,
                      " k_s_max=", k_s_max,
                      " k_s=", params.k_s,
                      " avgRemoved=", avgRemoved);
    }

    return params;
}

// Helper: Select seed customer (Algorithm 2, Line 3)
int Solution::selectSeedCustomer(std::mt19937 &rng)
{
    std::vector<int> servedCustomers;
    servedCustomers.reserve(no_customers);

    for (int customerId = 1; customerId <= no_customers; ++customerId)
    {
        if (customerId < static_cast<int>(customer_assignment.size()) &&
            customer_assignment[customerId] >= 0)
        {
            servedCustomers.push_back(customerId);
        }
    }

    if (servedCustomers.empty())
        return -1;

    std::uniform_int_distribution<size_t> seedDist(0, servedCustomers.size() - 1);
    return servedCustomers[seedDist(rng)];
}

// Helper: Execute removal plan (Algorithm 2, Line 9)
int Solution::executeRemovalPlan(Route &route, int routeIdx)
{
    // Sort by position (descending) and remove duplicates
    std::sort(removalPlan.begin(), removalPlan.end(),
              [](const auto &lhs, const auto &rhs)
              { return lhs.first > rhs.first; });
    removalPlan.erase(std::unique(removalPlan.begin(), removalPlan.end(),
                                  [](const auto &lhs, const auto &rhs)
                                  { return lhs.first == rhs.first; }),
                      removalPlan.end());

    // No artificial limit - let the algorithm's equations control the removals

    // Execute removals
    int removedCount = 0;
    for (const auto &[pos, node] : removalPlan)
    {
        if (pos <= 0 || pos >= static_cast<int>(route.nodes.size() - 1) || node == nullptr)
            continue;

        route.remove(node, pos);
        if (node->id >= 0 && node->id < static_cast<int>(customer_assignment.size()))
        {
            customer_assignment[node->id] = -1;
            sisrAbsent.push_back(node->id);
        }
        ++removedCount;
    }

    route.reCalc_informs();
    if (routeIdx >= 0 && routeIdx < static_cast<int>(changed.size()))
        changed[routeIdx] = true;

    return removedCount;
}

// Helper: Process single route removal (Algorithm 2, Lines 6-10)
bool Solution::processRouteRemoval(int neighborRoute, int closestCus, const SISRParams &params,
                                   std::unordered_set<int> &ruinedRoutes,
                                   int &totalRemoved, std::mt19937 &rng)
{
    // Validate route
    if (neighborRoute < 0 || neighborRoute >= static_cast<int>(routes.size()))
        return false;

    Route &route = routes[neighborRoute];
    if (route.numCus <= 0)
        return false;

    // ===== Line 8: Calculate string length =====
    int stringLength = calculateStringLength(neighborRoute, params.ell_s_max, rng);
    if (stringLength <= 0)
        return false;

    // ===== Split String Decision =====
    std::uniform_real_distribution<double> uniform01(0.0, 1.0);
    bool splitString = (sisr_config->splitRate > 0.0) && (stringLength > 1) &&
                       (uniform01(rng) < sisr_config->splitRate);

    // Prepare removal plan
    removalPlan.clear();
    removalPlan.reserve(stringLength);

    // ===== Line 9: Select customers to remove =====
    // closestCus is the customer from adjacency list (already closest to seed)
    if (!splitString)
        regularStringRemoval(neighborRoute, stringLength, closestCus);
    else
        splitStringRemoval(neighborRoute, stringLength, closestCus);

    // Execute removals
    int removedCount = executeRemovalPlan(route, neighborRoute);
    totalRemoved += removedCount;

    // ===== Line 10: Mark route as ruined =====
    ruinedRoutes.insert(neighborRoute);

    return removedCount > 0;
}

void Solution::applySISRRuin(const SISRConfig &config)
{
    if (!data)
        return;

    // Initialize buffers
    sisrInsertionStack.clear();
    sisr_config = &config;

    std::mt19937 &rng = config.engine();

    // ===== PAPER Algorithm 2, Lines 1-2: Calculate parameters =====
    SISRParams params = calculateSISRParameters(config, rng);
    if (params.k_s == 0)
        return; // No routes to ruin

    // ===== PAPER Algorithm 2, Line 3: Select seed customer =====
    int seedCustomer = selectSeedCustomer(rng);
    if (seedCustomer < 0)
        return; // No served customers

    // ===== PAPER Algorithm 2, Lines 4-10: Ruin routes from adjacency list =====
    std::unordered_set<int> ruinedRoutes; // R in paper (line 4)
    int routesProcessed = 0;
    int totalRemoved = 0;

    // for c ∈ adj(c_s^seed) and |R| < k_s do (line 5)
    if (seedCustomer >= 0 && seedCustomer < static_cast<int>(data->sisrAdjacency.size()))
    {
        const std::vector<int> &adjList = data->sisrAdjacency[seedCustomer];

        for (int neighbor : adjList)
        {
            // Check termination condition: |R| < k_s
            if (routesProcessed >= params.k_s)
                break;

            // ===== Line 6: if c ∉ A and t ∉ R then =====
            if (neighbor <= 0 || neighbor > no_customers)
                continue;
            if (neighbor >= static_cast<int>(customer_assignment.size()))
                continue;

            int neighborRoute = customer_assignment[neighbor];
            if (neighborRoute < 0) // Customer already removed (c ∈ A)
                continue;
            if (ruinedRoutes.find(neighborRoute) != ruinedRoutes.end()) // Route already ruined (t ∈ R)
                continue;

            // ===== Lines 7-10: Process this route =====
            if (processRouteRemoval(neighborRoute, neighbor, params, ruinedRoutes, totalRemoved, rng))
            {
                routesProcessed++;
            }
        }
    }

    // Clean up and recalculate
    erase_empty_routes();
    cal_fitness();

    // Log results
    if (data && data->trace_level >= 3)
    {
        Logger::debug("SISR Ruin: Removed ", totalRemoved, " customers (avgRemoved parameter: ", config.avgRemoved, ")");
    }
}

// Helper function for SISR removal operations
// Adds a segment of customers from a route to the removal plan
void Solution::addSegment(int routeIdx, int startPos, int length)
{
    if (length <= 0)
        return;
    if (routeIdx < 0 || routeIdx >= static_cast<int>(routes.size()))
        return;

    Route &route = routes[routeIdx];
    for (int offset = 0; offset < length; ++offset)
    {
        int pos = startPos + offset;
        if (pos <= 0 || pos >= static_cast<int>(route.nodes.size() - 1))
            break;
        removalPlan.emplace_back(pos, route.nodes[pos]);
    }
}

// Helper function to calculate string length for a route
// PAPER Equations 8-9: Calculate l_t^max and l_t
int Solution::calculateStringLength(int routeIdx, double ell_s_max, std::mt19937 &rng)
{
    if (routeIdx < 0 || routeIdx >= static_cast<int>(routes.size()))
        return 0;

    Route &route = routes[routeIdx];

    // ===== PAPER EQUATION 8: l_t^max = min{|t|, l_s^max} =====
    double l_t_max = std::min(static_cast<double>(route.numCus), ell_s_max);

    if (l_t_max <= 0)
        return 0;

    // ===== PAPER EQUATION 9: l_t = floor(U(1, l_t^max + 1)) =====
    std::uniform_real_distribution<double> l_t_dist(1.0, l_t_max + 1.0);
    return static_cast<int>(std::floor(l_t_dist(rng)));
}

void Solution::regularStringRemoval(int routeIdx, int stringLength, int closestCus)
{
    // ===== PAPER FIGURE 3: Regular String Removal =====
    // String must include c_t^* (closestCus from adjacency list)
    // closestCus is already the target customer - just find its position
    if (routeIdx < 0 || routeIdx >= static_cast<int>(routes.size()))
        return;
    if (!sisr_config)
        return;

    Route &route = routes[routeIdx];

    // Find position of closestCus in the route
    int closestCusPos = -1;
    for (int pos = 1; pos <= route.numCus; ++pos)
    {
        if (pos >= static_cast<int>(route.nodes.size()))
            break;
        Node *node = route.nodes[pos];
        if (node && node->id == closestCus)
        {
            closestCusPos = pos;
            break;
        }
    }

    if (closestCusPos < 0)
    {
        // Customer not found in route - use middle as fallback
        closestCusPos = (route.numCus + 1) / 2;
    }

    // Valid string start positions that include closestCusPos
    // String from startPos to startPos+stringLength-1 must contain closestCusPos
    int min_start = std::max(1, closestCusPos - stringLength + 1);
    int max_start = std::min(closestCusPos, route.numCus - stringLength + 1);

    if (min_start > max_start)
    {
        // Edge case: if constraints conflict, use fallback
        min_start = std::max(1, route.numCus - stringLength + 1);
        max_start = min_start;
    }

    // Randomly select start position from valid range
    std::mt19937 &rng = sisr_config->engine();
    std::uniform_int_distribution<int> start_dist(min_start, max_start);
    int startPos = start_dist(rng);
    addSegment(routeIdx, startPos, stringLength);
}

void Solution::splitStringRemoval(int routeIdx, int stringLength, int closestCus)
{
    // ===== PAPER FIGURE 4: Split String Removal =====
    // 1. Select a string of cardinality l+m that includes c_t* (closestCus)
    // 2. Within that string, preserve a random substring of m intervening customers
    // 3. Remove the remaining l customers from the string
    //
    // Paper: "m is maintained if U(0,1) is LARGER than β, or m reaches m_max"
    //        "If neither condition is satisfied, m is incremented"

    if (routeIdx < 0 || routeIdx >= static_cast<int>(routes.size()))
        return;
    if (!sisr_config)
        return;

    Route &route = routes[routeIdx];
    std::mt19937 &rng = sisr_config->engine();
    std::uniform_real_distribution<double> uniform01(0.0, 1.0);

    // ===== STEP 1: Determine m (number of preserved customers) =====
    // Paper: m_max = |t| - l (route size minus string length)
    int m_max = route.numCus - stringLength;
    if (m_max < 0)
        m_max = 0;

    int m = 1;
    // CORRECTED LOGIC: Continue while m < m_max AND U(0,1) ≤ β
    // Stop when: U(0,1) > β (maintain current m) OR m reaches m_max
    while (m < m_max)
    {
        double u = uniform01(rng);
        if (u > sisr_config->splitDepth) // ✓ FIXED: Stop when U > β
            break;
        m++; // Continue incrementing if U ≤ β
    }

    // ===== STEP 2: Find position of closestCus (c_t*) in the route =====
    int closestCusPos = -1;
    for (int pos = 1; pos <= route.numCus; ++pos)
    {
        if (pos >= static_cast<int>(route.nodes.size()))
            break;
        Node *node = route.nodes[pos];
        if (node && node->id == closestCus)
        {
            closestCusPos = pos;
            break;
        }
    }

    if (closestCusPos < 0)
    {
        // Customer not found in route - use middle as fallback
        closestCusPos = (route.numCus + 1) / 2;
    }

    // ===== STEP 3: Select l+m window that includes closestCusPos =====
    int windowSize = stringLength + m; // l + m

    // Ensure window doesn't exceed route size
    if (windowSize > route.numCus)
        windowSize = route.numCus;

    // Calculate valid window start positions that include closestCusPos
    int minWindowStart = std::max(1, closestCusPos - windowSize + 1);
    int maxWindowStart = std::min(closestCusPos, route.numCus - windowSize + 1);

    if (minWindowStart > maxWindowStart)
    {
        // Edge case: adjust to valid range
        minWindowStart = 1;
        maxWindowStart = std::max(1, route.numCus - windowSize + 1);
    }

    // Randomly select window start position
    std::uniform_int_distribution<int> windowDist(minWindowStart, maxWindowStart);
    int windowStart = windowDist(rng);
    int windowEnd = windowStart + windowSize - 1;

    // ===== STEP 4: Randomly place m preserved customers within the window =====
    // The preserved substring can be anywhere within the l+m window
    int maxPreserveStart = windowEnd - m + 1;
    int minPreserveStart = windowStart;

    if (minPreserveStart > maxPreserveStart)
        minPreserveStart = maxPreserveStart;

    std::uniform_int_distribution<int> preserveDist(minPreserveStart, maxPreserveStart);
    int preserveStart = preserveDist(rng);
    int preserveEnd = preserveStart + m - 1;

    // ===== STEP 5: Remove l customers from the window (outside preserved substring) =====
    // Remove customers BEFORE the preserved substring (within window)
    if (preserveStart > windowStart)
    {
        int removeLength = preserveStart - windowStart;
        addSegment(routeIdx, windowStart, removeLength);
    }

    // Remove customers AFTER the preserved substring (within window)
    if (preserveEnd < windowEnd)
    {
        int removeStart = preserveEnd + 1;
        int removeLength = windowEnd - preserveEnd;
        addSegment(routeIdx, removeStart, removeLength);
    }
}

// ============================================================================
// SISR RECREATE HELPER FUNCTIONS
// ============================================================================

// Helper: Select recreate ordering strategy (Algorithm 3, Line 2)
// Paper: "Set A is sorted by random, demand, far, and close by weights equal to four, four, two, and one"
SISRRecreateOrder Solution::selectRecreateOrder(std::mt19937 &rng)
{
    // Probabilistic selection with weights 4:4:2:1
    // Random: 4/11 (36.4%), Demand: 4/11 (36.4%), Far: 2/11 (18.2%), Close: 1/11 (9.1%)
    std::uniform_int_distribution<int> order_dist(1, 11);
    int r = order_dist(rng);

    if (r <= 4)
        return SISRRecreateOrder::RANDOM; // 4/11
    else if (r <= 8)
        return SISRRecreateOrder::DEMAND; // 4/11
    else if (r <= 10)
        return SISRRecreateOrder::FAR; // 2/11
    else
        return SISRRecreateOrder::CLOSE; // 1/11
}

// Helper: Sort absent customers according to selected ordering (Algorithm 3, Line 2)
void Solution::sortAbsentCustomers(std::vector<int> &customers, SISRRecreateOrder order, std::mt19937 &rng)
{
    auto depotDistance = [&](int customerId) -> int
    {
        if (customerId < 0 || !data || data->dis.empty())
            return 0;
        const auto &row0 = data->dis[0];
        if (customerId >= static_cast<int>(row0.size()))
            return 0;
        return row0[customerId];
    };

    switch (order)
    {
    case SISRRecreateOrder::RANDOM:
        std::shuffle(customers.begin(), customers.end(), rng);
        break;

    case SISRRecreateOrder::DEMAND:
        std::sort(customers.begin(), customers.end(), [&](int lhs, int rhs)
                  {
                      int demandL = (lhs >= 0 && lhs < static_cast<int>(data->customers.size()))
                                        ? data->customers[lhs].demand
                                        : 0;
                      int demandR = (rhs >= 0 && rhs < static_cast<int>(data->customers.size()))
                                        ? data->customers[rhs].demand
                                        : 0;
                      if (demandL == demandR)
                          return lhs < rhs;
                      return demandL > demandR; // Largest demand first
                  });
        break;

    case SISRRecreateOrder::FAR:
        std::sort(customers.begin(), customers.end(), [&](int lhs, int rhs)
                  {
                      int distL = depotDistance(lhs);
                      int distR = depotDistance(rhs);
                      if (distL == distR)
                          return lhs < rhs;
                      return distL > distR; // Farthest first
                  });
        break;

    case SISRRecreateOrder::CLOSE:
        std::sort(customers.begin(), customers.end(), [&](int lhs, int rhs)
                  {
                      int distL = depotDistance(lhs);
                      int distR = depotDistance(rhs);
                      if (distL == distR)
                          return lhs < rhs;
                      return distL < distR; // Closest first
                  });
        break;
    }
}

// Helper: Find best insertion position for customer (Algorithm 3, Lines 4-9)
Solution::InsertionPosition Solution::findBestInsertionPosition(int customerId, std::mt19937 &rng)
{
    InsertionPosition best;

    if (customerId <= 0 || customerId >= static_cast<int>(data->customers.size()))
        return best;

    Node *customerNode = &data->customers[customerId];
    int demand = customerNode->demand;

    if (demand > data->vehicle_cap)
        return best;

    // Random route order (Algorithm 3, Line 5)
    std::vector<int> routeOrder(routes.size());
    std::iota(routeOrder.begin(), routeOrder.end(), 0);
    std::shuffle(routeOrder.begin(), routeOrder.end(), rng);

    std::uniform_real_distribution<double> uniform01(0.0, 1.0);

    for (int routeIdx : routeOrder)
    {
        if (routeIdx < 0 || routeIdx >= static_cast<int>(routes.size()))
            continue;

        Route &route = routes[routeIdx];

        // Check capacity (Algorithm 3, Line 5: "which can serve c")
        if (route.load + demand > data->vehicle_cap)
            continue;

        // Try all positions in this route (Algorithm 3, Line 6)
        const int lastPosition = route.numCus;
        for (int pos = 0; pos <= lastPosition; ++pos)
        {
            // Blink rate (Algorithm 3, Line 7)
            if (sisr_config && uniform01(rng) < sisr_config->blinkRate)
                continue; // Skip this position with probability γ

            // Calculate insertion cost (Algorithm 3, Line 8)
            Node *prev = route.nodes[pos];
            Node *next = route.nodes[pos + 1];

            double deltaDistance = data->dis[prev->id][customerId] +
                                   data->dis[customerId][next->id] -
                                   data->dis[prev->id][next->id];
            double deltaCost = deltaDistance * data->travel_cost_unit;

            // Include penalty for tour length violations
            double newDistance = route.distance + deltaDistance;
            double oldPenalty = data->W_maxD * std::max(0, route.distance - data->maximum_tour);
            double newPenalty = data->W_maxD * std::max(0.0, newDistance - static_cast<double>(data->maximum_tour));
            double deltaPenalty = newPenalty - oldPenalty;

            double candidateCost = deltaCost + deltaPenalty;

            // Update best if this is better (Algorithm 3, Lines 8-9)
            if (candidateCost < best.cost)
            {
                best.cost = candidateCost;
                best.routeIdx = routeIdx;
                best.position = pos;
                best.valid = true;
            }
        }
    }

    return best;
}

// Helper: Insert customer at specified position (Algorithm 3, Lines 13-14)
bool Solution::insertCustomerAtPosition(int customerId, const InsertionPosition &insertPos)
{
    if (!insertPos.valid)
        return false;

    if (customerId <= 0 || customerId >= static_cast<int>(data->customers.size()))
        return false;

    if (insertPos.routeIdx < 0 || insertPos.routeIdx >= static_cast<int>(routes.size()))
        return false;

    Node *customerNode = &data->customers[customerId];
    Route &route = routes[insertPos.routeIdx];

    route.insert(customerNode, insertPos.position);
    route.calc_fitness();

    // Ensure changed vector is sized correctly
    if (changed.size() < routes.size())
        changed.resize(routes.size(), false);
    changed[insertPos.routeIdx] = true;

    // Update customer assignment
    if (customerId < static_cast<int>(customer_assignment.size()))
        customer_assignment[customerId] = insertPos.routeIdx;

    sisrInsertionStack.push_back(customerId);
    return true;
}

// ============================================================================
// SISR RECREATE METHOD - PAPER-COMPLIANT IMPLEMENTATION
// ============================================================================

void Solution::applySISRRecreate(const SISRConfig &config)
{
    // ===== PAPER ALGORITHM 3: Greedy Insertion with Blinks =====
    // Input: Ruined solution with absent customers set A
    // Output: Recreated solution with customers reinserted

    if (!data)
        return;

    if (sisrAbsent.empty())
        return;

    std::mt19937 &rng = config.engine();
    sisr_config = &config;

    // Initialize insertion tracking
    sisrInsertionStack.clear();

    // Copy absent customers to working list
    std::vector<int> pending = sisrAbsent;
    sisrAbsent.clear();
    std::vector<int> unassigned;
    unassigned.reserve(pending.size());

    if (pending.empty())
    {
        cal_fitness();
        return;
    }

    // ===== STEP 1: Select ordering strategy (Algorithm 3, Line 2) =====
    // Weights: Random=4, Demand=4, Far=2, Close=1
    SISRRecreateOrder selectedOrder = selectRecreateOrder(rng);

    // ===== STEP 2: Sort customers by selected ordering (Algorithm 3, Line 2) =====
    sortAbsentCustomers(pending, selectedOrder, rng);

    // ===== STEP 3: Insert each customer (Algorithm 3, Lines 3-14) =====
    for (int customerId : pending)
    {
        // Lines 4-9: Find best insertion position
        InsertionPosition bestPos = findBestInsertionPosition(customerId, rng);

        // Line 10-12: Create new route if no valid position found
        if (!bestPos.valid && routes.size() < static_cast<size_t>(data->no_vehicles))
        {
            // Create new route for this customer
            if (customerId > 0 && customerId < static_cast<int>(data->customers.size()))
            {
                Node *customerNode = &data->customers[customerId];
                Route newRoute(data);
                newRoute.insert(customerNode, 0);
                newRoute.calc_fitness();
                routes.push_back(newRoute);

                // Update tracking
                if (changed.size() < routes.size())
                    changed.resize(routes.size(), false);
                changed.back() = true;

                if (customerId < static_cast<int>(customer_assignment.size()))
                    customer_assignment[customerId] = static_cast<int>(routes.size()) - 1;

                sisrInsertionStack.push_back(customerId);
                continue;
            }
        }

        // Lines 13-14: Insert customer at best position
        if (!insertCustomerAtPosition(customerId, bestPos))
        {
            // Failed to insert - add to unassigned list
            unassigned.push_back(customerId);
        }
    }

    // Store any customers that couldn't be inserted
    if (!unassigned.empty())
        sisrAbsent = unassigned;

    // Recalculate solution fitness
    cal_fitness();
}
